#!/bin/sh

export PATH="$PATH:/usr/bin:/bin:/usr/sbin:/sbin"

if [ "${initos_debug}" = 1 ]; then
  set -x
fi

# Main function after busybox and sys fs setup
initramfs_init() {

  logi "Starting initramfs $(uname -r)"

  mkdir -p /sysroot /z /x /initos /boot/efi \
     /lib/modules /lib/firmware \
     /home /var/log /var/cache

  initramfs_mods

  # Mount the rest of the modules - usually finding the root is not
  # possible without this.
  #udev_start

  # Not needed - can try looking for the part, will retry
  #udevadm settle

  # No longer checking EFI - if the 
  if [ -n "${pub_key}" ]; then
    SECURE=1
  else
    SECURE=0
  fi

  # Will be moved to recovery image
  mount -t tmpfs root-tmpfs /initos
  mkdir -p /initos/sidecar /initos/ro/sidecar /initos/ro/root \
     /initos/work/sidecar /initos/rw/sidecar /sysroot

  find_boot
  if [ $? -ne 0 ]; then
    fatal "Failed to find host sidecar"
  fi

  # Mount the SQFS and overlayfs
  #mount_initos

  if [ "${initos_sh}" = 1 ]; then
    sh
  fi

  move_mounted_to_sysroot
  INIT=${initos_init:-/sbin/initos-init}
  exec switch_root /sysroot ${INIT}

  lfatal "Failed to switch root"
}


## First step - expand busybox and mount the basic filesystems
initramfs_1st() {
  # No kernel options processed - we build intitramfs and cmdline in the same efi.
  # May read an initrc file if needed - but the goal is to keep it precise and simple.
  # Initramfs does not include the links (for some reason?)
  /bin/busybox mkdir -p /sbin /usr/bin \
    /usr/sbin \
    /dev \
    /media/cdrom \
    /media/usb \
    /tmp \
    /etc \
    /dev/shm /run /proc /sys

  # Spread out busybox symlinks and make them available without full path
  # This appears slightly faster than having the initramfs include all symlinks ?
  /bin/busybox --install -s

  # Make sure /dev/null is a device node. If /dev/null does not exist yet, the command
  # mounting the devtmpfs will create it implicitly as an file with the "2>" redirection.
  # The -c check is required to deal with initramfs with pre-seeded device nodes without
  # error message.
  [ -c /dev/null ] || mknod -m 666 /dev/null c 1 3

  mount -t sysfs -o noexec,nosuid,nodev sysfs /sys

  mount -t devtmpfs -o exec,nosuid,mode=0755,size=2M devtmpfs /dev 2>/dev/null \
    || mount -t tmpfs -o exec,nosuid,mode=0755,size=2M tmpfs /dev

  # Make sure /dev/kmsg is a device node. Writing to /dev/kmsg allows the use of the
  # earlyprintk kernel option to monitor early init progress. As above, the -c check
  # prevents an error if the device node has already been seeded.
  [ -c /dev/kmsg ] || mknod -m 660 /dev/kmsg c 1 11u

  mount -t proc -o noexec,nosuid,nodev proc /proc


  # pty device nodes (later system will need it)
  [ -c /dev/ptmx ] || mknod -m 666 /dev/ptmx c 5 uub
  [ -d /dev/pts ] || mkdir -m 755 /dev/pts

  mount -t devpts -o gid=5,mode=0620,noexec,nosuid devpts /dev/pts  
  # shared memory area (later system will need it)
  mount -t tmpfs tmpfs /run
  # can't be moved for some reason
  # mount -t tmpfs -o nodev,nosuid,noexec shm /dev/shm


  # console loglevel 2 (critical)
  # default messages (no loglevel): 4 (warning)
  # min console log level
  # default console log level 7
  #sysctl -w kernel.printk="2 4 1 7"

}

# Load modules we may need - modules are also loaded if we get to udev
# or nlplug-findfs, but we may skip that if the core modules are enough.
initramfs_mods() {

  # Required on alpine kernel - without this there is no display
  # Debian appears to have it compiled in the kernel.
  for m in simpledrm scsi_mod sd_mod \
     nvme squashfs loop dm-verity mmc_block efivarfs \
     ext4 usbcore ehci-hcd ohci-hcd xhci-hcd usb-storage ; do
     
    modprobe $m >> /tmp/initos.log 2>&1
  done
}



# All remaining mounted dirs will be moved under same dir in /sysroot,
# ready to switch_root
move_mounted_to_sysroot() {
  # Will be started again in sysroot
  #udevadm control --exit || true

  # From original alpine init
  cat /proc/mounts 2>/dev/null | while read DEV DIR TYPE OPTS ; do
    if [ "$DIR" != "/" -a "$DIR" != "/sysroot" -a -d "$DIR" ]; then
      mkdir -p /sysroot$DIR
      mount -o move $DIR /sysroot$DIR
    fi
  done

  sync
}

# Info log - shown on console, logged.
logi() {
	echo "INITOSRD: $@" > /dev/kmsg
}

lfatal() {
  echo "FAILED: "$@""
  local save=/boot/efi/log
  mkdir -p $save

  blkid > $save/blkid.log
  dmesg > $save/dmesg.log
  cat /proc/filesystems > $save/filesystems
  cat /proc/devices > $save/devices
  lsmod > $save/lsmod.log

  
  # TODO: if /boot/efi is mounted, save to the EFI partition
  blkid
  
  if [ "$SECURE_MODE" = "1" ]; then 
    echo "Rebooting in 20 sec. Block devices:"
    sleep 20
    sync
    reboot -f
  else
    echo "Recovery shell, insecure boot. Fix the issue and exit to continue."
    /bin/sh
  fi
}

# retry function. Not used right now, will be used for LVM open
retry() {
  retries=$1
  shift

  count=0
  until "$@"; do
    exit=$?
    wait=$((count + 1))
    count=$((count + 1))
    if [ "$count" -lt "$retries" ]; then
      #echo "Retry $count/$retries exited $exit, retrying in $wait seconds..."
      sleep $wait
    else
      echo "Retry $count/$retries exited $exit, no more retries left."
      return $exit
    fi
  done
}


# Find_root looks for all EFI partitions, and attempts to mount
# the partition having a file /initos/version with same content
# as the hash of the initos.verity. As long as the hash is matching
# it doesn't matter which partition we use.
#
# There is a risk that the file is corrupted - and the alternate
# partition would be good, but usually the A/B have different 
# versions (previous/next), and on reboot we would pick that.

# Will look for the sidecar image.
#
# Current logic:
# - BTRFS disk with label INITOS or INITOSUSB (new world)
# - EXT4 disk with label H-STATE or UBUNTU (for upgraded laptos - more can be added)
# - FAT (EFI) disk with label BOOTA, BOOTB - to be removed
# 
# The disks are checked for /initos/BOOTA and /initos/BOOTB - and 
# initos.hash and sidecar.hash.
# 
# In insecure mode, the /z/initos/sidecar and /z/initos/oop are also used,
# no signature. If an attacker has access to the machine - they can take control
# anyways by booting another OS.
find_boot() {
  
  local tag9p=/sys/bus/virtio/drivers/9pnet_virtio/virtio0/mount_tag
  if [ -f ${tag9p} ]; then
    mkdir -p /src
    mount -t 9p -o trans=virtio,version=9p2000.L $(cat ${tag9p}) /src
  fi

  # Command line option - sqfs in a device, usually VM
  if [ "${SECURE_MODE}" != "1" -a -n "${initos_sidecar}" ]; then
      # Wait for things to settle
      retry 4 [ -e ${initos_sidecar} ]
      mount -t squashfs ${initos_sidecar} /initos/ro/sidecar
      logi "Mounted without dm_verity ${initos_sidecar}"
      return 0
  fi

  # Main file - if /dev/mapper/initos can be mounted, will assume success.
  local vname=initos

  local first=ROOTA

  #local hashf=${3:-$(cat /local/sidecar.hash)}

  # findfs doesn't work well if multiple partitions with same label are present.
  # This just waits for the expected label to show up, will try all of them
  retry 4 findfs LABEL=$first >/dev/null 2>&1

  mkdir -p /initos/ro/roota
  mount -o ro LABEL=$first /initos/ro/roota || lfatal "Failed to mount rootfs"

  if [ "${SECURE_MODE}" == "1" ]; then
    mount_verity
    return
  fi


  if [ -f /initors/ro/roota/initos/sidecar.sqfs ]; then
    mount -t squashfs /initors/ro/roota/initos/sidecar.sqfs /initos/ro/sidecar || lfatal "Failed to mount sidecar on the rootfs"
  else
    mount -o bind /initos/ro/roota /initos/ro/sidecar
  fi
}

# WIP: read the signature
mount_verity() {
  local mountp=$1
  local device=$2
  local hashf=$3

  minisign -V -P ${pub_key} -m /initos/ro/roota/initos/config || lfatal "Failed to verify initos config"
  # Should export 'hashf' - can as well be a script, if it is signed.
  . /initos/ro/roota/initos/config

  veritysetup open $mountp/sidecar.sqfs sidecar \
        $mountp/sidecar.sqfs.verity ${hashf} 
    
  if [ $? -eq 0 ]; then
      mount -t squashfs /dev/mapper/sidecar /initos/ro/sidecar
      if [ $? -ne 0 ]; then
        return 2
      fi
      
      return 0 
  fi
  return 1
}


# This is called with 'env' set from kernel cmdline - all unknown foo=bar
# Args are all kernel unknown.
if [ "$$" = "1" ]; then
  initramfs_1st
  
  initramfs_init
else
  "$@"
fi
