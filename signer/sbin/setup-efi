#!/bin/sh

# Setup for the UKI (signed kernel + signed configs including SHA256 for next stages).
#
# Input:
# - /data/efi/initos - the directory with the initos.sqfs and sidecar.sqfs images
# - The /config directory is expected to contain uefi-keys (will be created if missing)
#
# Output:
# - /data/efi/keys - the keys used to sign the images (to be added to host)
# - /data/efi/EFI/BOOT/BOOTx64.EFI - the signed UKI image
#
#
# It will start by generating Verity signatures for the .sqfs images in
# /data/efi/initios (generated as part of the rootfs)
# built, and create the EFI UKI with corresponding flags.
#
# /boot, /lib/modules and /lib/firmware are expected to be mounted from another
# image or disk, or part of the signer image.
#
# Create the final disk by copying to the unused existing EFI partition - the active boot can't be
# changed, the files will be in use.

set -x
set -e

# Destination dir for the efi partition artifacts.
# May include additional files to bake into images.
# Signing the images also requires a volume holding the signing keys
# and configs.

DATA=${DATA:-/data}

# Expectes kernel to be mounted here - with ./boot, ./lib/modules, firmware
KERNEL_DIR=${KERNEL_DIR:-/mnt/modloop}
KERNEL=${KERNEL:-${KERNEL_DIR}/vmlinuz}

OUT=${OUT:-/data/efi}
DEST=${OUT}

STUB=${STUB:-/usr/lib/efi-stub/ministub.efi}
INITRD_SRC=${INITRD_SRC:-/initrd}


# Hardcoded in stub - any change must be done in both places.
kernel_offset='0x30000000'
cfg_offset=0x20000000

SECRETS=${SECRETS:-/var/run/secrets/uefi-keys}

# Create unsigned EFI. This simply copies files to the right place for signing or
# use without signature.
unsigned() {
  xcmd="$1"

  mkdir -p ${DEST}/EFI/LINUX ${DEST}/EFI/BOOT

  local cmd="console=tty1 loglevel=6 iomem=relaxed quiet net.ifnames=0 panic=5"
  
  initrd=${DEST}/EFI/LINUX/INITRD.IMG
  if [ -f ${initrd} ]; then
    cmd="initrd=\\EFI\\LINUX\\INITRD.IMG $cmd"
  fi

  #if [ ! -f ${DEST}/EFI/LINUX/CMDLINE ]; then
  echo "$cmd $xcmd"  > ${DEST}/EFI/LINUX/CMDLINE
  #fi 

  cp ${KERNEL} ${DEST}/EFI/LINUX/KERNEL.EFI
  cp ${STUB} ${DEST}/EFI/BOOT/BOOTx64.EFI
}

# EFI will generate a config including SHA256 of initrd (if any), kernel size and command line
#
# The files are expected to be in ${OUT}/EFI/LINUX/{KERNEL.EFI,CMDLINE,INITRD.IMG}
# If INITRD.IMG is missing - it is assumed the kernel has disk drivers and EXT4 support.
#
# A rootfs should be already created and dm-verity signed.
efi() {
  local xtra_cmd=${1:-}

  PUB=$(sed -n '2p' ${SECRETS}/minisign.pub)
  mkdir -p ${DEST}/EFI/LINUX ${DEST}/EFI/BOOT

  local cmd="pub_key=${PUB} console=tty1 loglevel=6 net.ifnames=0 panic=5 "

  # TODO: add a file an create another config.cpio - command line can be set by efibootmgr.
  # Technically if the command line can be changed an attacker can also set rdinit=/bin/sh - the bootloader must
  # be locked down and EFI restricted just like TPM
  # Main setting - iomem - allows flashing bios, etc.

  initrd=${INITRD:-${DEST}/EFI/LINUX/INITRD.IMG}

  echo UKI >/tmp/ukicfg

  # This is required if using startImage - but a security risk
  # since the kernel can be extracted and used with random cmd
  # 
  # sbsign --cert ${SECRETS}/db.crt \
  #   --key ${SECRETS}/db.key \
  #   --output /tmp/kernel.signed.efi \
  #   ${KERNEL}  
  cp ${KERNEL} ${DEST}/EFI/LINUX/KERNEL.EFI
  
  cat ${KERNEL} | wc -c >>/tmp/ukicfg
  sha256sum ${KERNEL} | cut -d" " -f 1 >>/tmp/ukicfg
  
  if [ -f ${initrd} ]; then
    cat ${initrd} | wc -c >>/tmp/ukicfg
    sha256sum ${initrd} | cut -d" " -f 1 >>/tmp/ukicfg
  else
    echo 0 >> /tmp/ukicfg
    echo 0 >> /tmp/ukicfg
  fi

  #echo "console=tty1 loglevel=1 quiet net.ifnames=0 panic=5" >>/tmp/ukicfg
  echo "$cmd ${xtra_cmd}" >>/tmp/ukicfg
  echo >>/tmp/ukicfg

  cat /tmp/ukicfg

  # Even if embedded, the kernel needs to be signed.
  # Not clear why not let it on disk.
  # Note that extracting the signed kernel is possible, and
  # then it can be launched with a different command line from
  # boot loader... So it seems this approach may not work so well.
   
  # TODO: the kernel and config can be loaded and checked, we only need a SHA
  # and we could just link a public key and have the config signed.
  objcopy \
    --add-section .cfg="/tmp/ukicfg" --change-section-vma .cfg=$cfg_offset \
    ${STUB} \
    /tmp/InitOS-unsigned.EFI

#--add-section .linux="${KERNEL}" --change-section-vma ".linux=$kernel_offset" \
    
  mkdir -p ${DEST}/EFI/BOOT

  sbsign --cert ${SECRETS}/db.crt \
    --key ${SECRETS}/db.key \
    --output ${DEST}/EFI/BOOT/BOOTx64.EFI \
    /tmp/InitOS-unsigned.EFI
  
  ls -l ${DEST}/EFI/BOOT ${DEST}/EFI/LINUX

  chmod -R 755 ${DEST}
}


# Generate the key pairs for signing the kernel and the disk image.
# This is done before install - as a separate step/process - the rest can be automated easily,
# but signing must be done on a secure machine and is specific to each user.
sign_init() {
  local u=${DOMAIN:-mesh.internal}

  SECRETS=${SECRETS:-/var/run/secrets/uefi-keys}

  if [ -f ${SECRETS}/root.key ] ; then
    echo "Keys already exist"
    return 0
  fi

  efi-mkkeys -s ${u} -o ${SECRETS}

  # Generate a 'mesh root' - both SSH and https.
  # Will be bundled on all signed images, and used to encrypt the LUKS pass.
  openssl genpkey -algorithm EC -pkeyopt ec_paramgen_curve:P-256 \
    -out ${SECRETS}/root.key

  openssl ec -in ${SECRETS}/root.key -pubout -out \
    ${SECRETS}/root.pem

  ssh-keygen -y -f ${SECRETS}/root.key > ${SECRETS}/authorized_keys

  minisign -GW -s ${SECRETS}/minisign.key -p ${SECRETS}/minisign.pub
  PUB=$(sed -n '2p' ${SECRETS}/minisign.pub)

  echo $PUB
  #cat ${SECRETS}/minisign.pub

  cat ${SECRETS}/authorized_keys
}

# Creat a sqfs under $1 with the name $2, containing all files in this
# container.
#
# Another way is to export (pull and export or using crane) and create
# the sqfs externally.
sqfs() {
  local DIR=${1:-/data/initos}
  local name=${2:-sidecar}

  # -one-file-system also works on the host - but not so well in a container.

  # buildah unshare -m A=debui -- \
  #  sh -c 'tar -cf - -C ${A} .' | \
  #   sqfstar ${WORK}/vimg/virt.sqfs -e .dockerenv

  # Excluding boot from the sqfs (kernel remains on the image and is used to build
  # the EFI, but no need to add a copy)
  # However ./the cloud kernel is needed for VM

  mkdir -p ${DIR}
  rm -f ${DIR}/${name}.*

  cd /mnt/modloop

  # Busybox tar does not support this.
  tar cf - -C /mnt/modloop lib/modules lib/firmware boot -C /mnt/sidecar . | \
    mksquashfs -comp gzip -no-exports -no-fragments -no-duplicates -all-root - ${DIR}/${name}.sqfs -tar -noappend   \
     -regex \
     -e "x/.*" \
     -e "etc/uefi-keys" \
     -e ".dockerenv" \
     -e "data/.*" \
     -e "proc/.*" \
     -e "sys/.*" \
     -e "run/.*" \
     -e "tmp/.*" \
     -e "var/cache/apt/.*" \
     -e "etc/apk/cache.*"
  ls -l ${DIR}/${name}.sqfs

  echo "Created ${DIR}/${name}.sqfs"

  # TODO: find offset aligned to sector, save the offset along with the verity hash
  # technically for same parameters - the same hash is generated, so may not need to be transferred.
  #Ex:  dmsetup create vroot --readonly --table \
  # "0 2097152 verity 1 /dev/sda1 /dev/sda2 4096 4096 262144 1 sha256 "\
  # "4392712ba01368efdf14b05c76f9e4df0d53664630b5d48632ed17a137f39076 "\
  # "1234000000000000000000000000000000000000000000000000000000000000"

  # dm-mod.create="verity,,,ro,0 131072 verity 1 /dev/mmcblk0p1 /dev/mmcblk0p2 4096 4096 16384 1 sha256 \
  #             b96a69664f9279857931dbf64f942caf909076e40fd5bd5ed8d30b53ff922941 \
  #             2a4c7638f03b92bdb92d7284a742e0c4407c9ef65fdf2a7ea78ed02fde4a518b 1 ignore_zero_blocks"
  #
  # dm-mod.create="<name>,<uuid>,<minor>,<flags>,[dm_table_params {dm_verity_params}]"
  # dm_table_params="<start_sector> <num_sectors> <target_type> <dm_verity_params>"
  # dm_verity_params="<version> <dev> <hash_dev> <data_block_size> <hash_block_size> <num_data_blocks> \
  #                       <hash_start_block> <algorithm> <digest> <salt> [<#opt_params> <opt_params>]"

  # TODO: check if older
  veritysetup format --data-block-size=4096 --hash-block-size=4096 \
    --root-hash-file=${DIR}/${name}.hash \
    ${DIR}/${name}.sqfs \
    ${DIR}/${name}.sqfs.verity
}


# Build the initramfs with modules for a non-custom kernel lacking storage drivers.
#
# Expectes /boot, /lib/modules, /lib/firmware to have the right
# mounts and /boot/version to hold the desired kernel version.
#
# This runs in an alpine container - the init will be based
# on the musl binaries plus minisign.
build_initrd() {
  local destdir=${1:-/data/boot/}

  local VER=$(cat /boot/version)
  local img=${destdir}/initos-initrd.img
  mkdir -p ${destdir}

  [ ! -f /lib/modules/${VER}/modules.dep ] && echo "Missing modules" && return

  # Uses mkinitfs.conf added from file in the docker image.
  # Other options: virtio, squashfs, 9p, raid, cdrom, lvm, ext4, kms (video)

  # -k - keep the file
  # -t - temp dir where all is stored
  # -i - what init file to use - replace default with our script.
  #  -F "ata base keymap mmc nvme scsi usb cryptsetup squashfs ext4 initos eudev" \

  rm -rf ${destdir}/initrd
  mkinitfs -i /sbin/initos-initrd \
    -t ${destdir}/initrd -k \
    -F "ata base keymap mmc nvme scsi usb cryptsetup squashfs ext4 initos eudev" \
    -o ${img} $VER
}

patch_initrd() {
  INIT_PATCH=/tmp/initrd-patch.cpio.gz
  (find /local |
    sort | cpio --quiet --renumber-inodes -o -H newc | gzip) >${INIT_PATCH}
}


mkinitramfs() {
  local base=$1
  local out=$2
  (cd $base && find |
    sort | cpio --quiet --renumber-inodes -o -H newc | gzip) > ${out}
}

unmkinitramfs() {
  local f=$1
  local out=$2
  mkdir -o $out
  
  gzip -dc $f | (cd $out; cpio -i --no-absolute-filenames --quiet  ) 
}

base_initrd() {
  mkdir -p ${DEST}/EFI/LINUX ${DEST}/EFI/BOOT
  if [ -d /ws/signer ]; then
    cp -a /ws/signer/initrd/* /initrd
  fi  
  INITRD=${DEST}/EFI/LINUX/INITRD.IMG
  (cd ${INITRD_SRC:-/initrd} && find |
    sort | cpio --quiet --renumber-inodes -o -H newc | gzip) >${INITRD}

}

booster_initrd() {
  ln -s /mnt/modloop/lib/modules /lib/modules
  ln -s /mnt/modloop/lib/firmware /lib/firmware
  
  # 23M
  booster build -f --universal /data/initrd.booster.img --kernel-version=$(cat /mnt/modloop/boot/version)
}


# Make sure the initrd.img and sidecar.sqfs files exist.
# They are used for creating the EFI file.
#
# The files are created on the /data dir
prepare() {
  local variant=${1:-deb}
  mkdir -p /data/boot-${variant} /data/efi-${varaint} /data/initos-${variant}

  if [ -d /ws/signer ]; then
    cp -a /ws/signer/sbin/* /sbin
    rm /data/boot-${variant}/initos-initrd.img
    rm -rf /data/boot-${variant}/initos-initrd
  fi

  if [ ! -e /data/boot-${variant}/initos-initrd.img ]; then
    if [ -e /mnt/modloop/boot -a ! -e /boot/version ]; then
      rm -rf /boot /lib/modules /lib/firmware
      ln -s /mnt/modloop/boot /boot
      ln -s /mnt/modloop/lib/firmware /lib/firmware
      ln -s /mnt/modloop/lib/modules /lib/modules
    fi
    build_initrd /data/boot-${variant}
  fi

  if [ ! -e /data/initos-${variant}/sidecar.sqfs ]; then
    if [ -e /mnt/modloop/boot -a ! -e /boot/version ]; then
      rm -rf /boot /lib/modules /lib/firmware
      ln -s /mnt/modloop/boot /boot
      ln -s /mnt/modloop/lib/firmware /lib/firmware
      ln -s /mnt/modloop/lib/modules /lib/modules
    fi
    sqfs /data/initos-${variant}
  fi
}

if [ -z ${1+x} ]; then
  efi
else
  "$@"
fi
