#!/bin/sh


# Setup for the UKI (signed kernel + initrd + signed configs/hashes).
# Input: 
# - VERSION env variable
# - 3 files in ${DATA:-/data}/boot:  cmdline, initrd.img and vmlinuz-$VERSION
# - /run/secrets/uefi-keys - the signing keys directory (optional, if directory exists but
# keys are missing - new kesy are generated)
# 
# Output:
# - ${OUT:-/data}/efi/EFI/BOOT/BOOTx64.EFI - the UKI image
# - ${OUT:-/data}/efi/EFI/Linux/initrd.img - the initrd (if required)

set -x
set -e

# uki is assembling the final BOOTx64.EFI image based on 2 files:
# vmlinuz and cfg 
# 
# The cfg includes cmdline, (optional) initrd and initrd.sha256
# and rootca/authorized_keys - and reflects user config.
#
# UKI2 is regenerated and signed for each kernel or user rootca
# update.
uki2() {
  # small subset of efi-mkuki
  linux=${linux:-vmlinuz-${VERSION}}
  cmdline=${cmdline:-cmdline}

  kernel_offset='0x2000000' # 32M

  objcopy \
    --add-section .cfg="$cmdline" --change-section-vma .cfg=0x30000 \
    --add-section .linux="$linux"     --change-section-vma ".linux=$kernel_offset"  \
    "$efistub" "$output"

  # This corrects putting sections below the base image of the stub.
  objcopy --adjust-vma 0 "$output"
}

# uki is assembling the final BOOTx64.EFI image based on 3 files, vmlinuz
# cmdline and initrd.
uki() {
  # small subset of efi-mkuki
  linux=${linux:-vmlinuz-${VERSION}}
  cmdline=${cmdline:-cmdline}
  initrd=${initrd:-initrd}

  kernel_offset='0x2000000' # 32M

  # kernel_size="$(stat -c '%s' "$linux")"
  # # Initrd offset is the first page-aligned (0x...000) address 
  # # that's 0x1000000 (16MiB) from the end of the kernel.
  # initrd_offset="0x$(printf '%x\n' "$(( ( 1 + ( 0x1000000 + $kernel_offset + $kernel_size ) / 0x1000) * 0x1000 ))")"
  initrd_offset='0x3000000' # 48M
  # Leave 16M for the kernel - current compressed kernel is about 8M.
  # This may need to be adjusted for larger kernels

  objcopy \
    --add-section .cmdline="$cmdline" --change-section-vma .cmdline=0x30000 \
    --add-section .linux="$linux"     --change-section-vma ".linux=$kernel_offset"  \
    --add-section .initrd="$initrd"   --change-section-vma ".initrd=$initrd_offset" \
    "$efistub" "$output"

  # This corrects putting sections below the base image of the stub.
  objcopy --adjust-vma 0 "$output"
}

# Sign the UKI using sbsign. Keys must be present in /var/run/secrets
sign() {
  # Alpine expects keys on /etc/uefi-keys/{db.crt,db.key}
  if [ ! -f /var/run/secrets/uefi-keys/db.crt ]; then
    sign_init
  else
    cp -a /var/run/secrets/uefi-keys /etc
  fi

  uki2

  sbsign --cert /var/run/secrets/uefi-keys/db.crt \
      --key /var/run/secrets/uefi-keys/db.key \
      --output ${DEST}/InitOS-signed.EFI \
      ${DEST}/InitOS-unsigned.EFI
}

# Generate the key pairs for signing the kernel and the disk image.
# This is for testing/dev - keys should be encrypted and stored in a 
# secret manager, and only accessed on the signing machine during
# signing (not visible during build).
#
# Signing requires only db.crt and db.key.
#
# TODO: signd service, with audit, etc.
sign_init() {
  local u=${DOMAIN:-mesh.internal}

  efi-mkkeys -s ${u} -o /var/run/secrets/uefi-keys
}

if [ -z ${1+x} ] ; then
  sign
else
  "$@"
fi
