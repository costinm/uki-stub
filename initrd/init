#!/bin/sh

# Init file for secure boot, based on busybox.
# This is only needed for 'pre-built' generic kernels from
# distributions - it is better to build a kernel with the 
# proper storage drivers included and remove the complexity
# of having an initrd and complex boot.

export PATH="$PATH:/usr/bin:/bin:/usr/sbin:/sbin"

# Initrd portion, responsible to find the verity-signed 
# sqfs and give control to it.
# 
# As alternative: custom kernel with verity and disk modules
# linked in, and InitOS and verity on a ext2 partition will
# also work the same (like ChromeOS).
# 
# No other code should be included here.

# Based on Alpine mkinitrd, but with different init script:
# - removed all networking or alpine-specific init - only job is to load a rootfs
#
# This allows using the simpler initrd, with a number of small 
# specialized functions.

# Main entry point - after mounting the system dirs.
# At the end, /sysroot will include the InitOS verified
# image and will get control.
# 
# Should be equivalent to kernel compiled with verify
# and disk drivers linked in, mounting an EFI disk
# with verity as rootfs.
initramfs_init() {
  # Normally unknown cmd line parameters are passed as env.
  # DO NOT USE ...initrd - early EFI will attempt to load it...

  if [ "${initos_debug}" = 1 ]; then
    set -x
  fi
  logi "Starting INITOS initramfs $(uname -r) hash=$(cat /local/sidecar.hash)"

  mkdir -p /sysroot /z /x /initos /boot/efi \
     /lib/modules /lib/firmware \
     /home /var/log /var/cache

  # Load a set of core modules we use to load the VERITY
  # image. Udev will not load them by default, only modules for devices.
  initramfs_mods

  # Mount the rest of the modules - usually finding the root is not
  # possible without this.
  udev_start

  # Not needed - can try looking for the part, will retry
  udevadm settle
 
  # The current boot for InitOS is signifcant - it indicates what partition
  # to check first.
  # TODO: also check a local file - we want the signed EFI to only work in secure mode.
  check_efi

  # Will be moved to recovery image
  mount -t tmpfs root-tmpfs /initos
  mkdir -p /initos/sidecar /initos/ro/sidecar \
     /initos/work/sidecar /initos/rw/sidecar

  # Set in qemu - early shell waiting for pty to show up.
  find_boot
  if [ $? -ne 0 ]; then
    fatal "Failed to find host sidecar"
  fi

  # Mount the SQFS and overlayfs
  mount_initos

  if [ "${initos_debug}" = 1 ]; then
    sh
  fi

  move_mounted_to_sysroot
  INIT=${init:-/sbin/initos-init}
  exec switch_root /sysroot ${INIT}

  lfatal "Failed to switch root"
}


## First step - expand busybox and mount the basic filesystems
initramfs_1st() {
  # No kernel options processed - we build intitramfs and cmdline in the same efi.
  # May read an initrc file if needed - but the goal is to keep it precise and simple.
  # Initramfs does not include the links (for some reason?)
  /bin/busybox mkdir -p /usr/bin \
    /usr/sbin \
    /dev \
    /media/cdrom \
    /media/usb \
    /tmp \
    /etc \
    /dev/shm /run /proc /sys

  # Spread out busybox symlinks and make them available without full path
  # This appears slightly faster than having the initramfs include all symlinks ?
  /bin/busybox --install -s

  # Make sure /dev/null is a device node. If /dev/null does not exist yet, the command
  # mounting the devtmpfs will create it implicitly as an file with the "2>" redirection.
  # The -c check is required to deal with initramfs with pre-seeded device nodes without
  # error message.
  [ -c /dev/null ] || mknod -m 666 /dev/null c 1 3

  mount -t sysfs -o noexec,nosuid,nodev sysfs /sys

  mount -t devtmpfs -o exec,nosuid,mode=0755,size=2M devtmpfs /dev 2>/dev/null \
    || mount -t tmpfs -o exec,nosuid,mode=0755,size=2M tmpfs /dev

  # Make sure /dev/kmsg is a device node. Writing to /dev/kmsg allows the use of the
  # earlyprintk kernel option to monitor early init progress. As above, the -c check
  # prevents an error if the device node has already been seeded.
  [ -c /dev/kmsg ] || mknod -m 660 /dev/kmsg c 1 11u

  mount -t proc -o noexec,nosuid,nodev proc /proc


  # pty device nodes (later system will need it)
  [ -c /dev/ptmx ] || mknod -m 666 /dev/ptmx c 5 uub
  [ -d /dev/pts ] || mkdir -m 755 /dev/pts

  mount -t devpts -o gid=5,mode=0620,noexec,nosuid devpts /dev/pts  
  # shared memory area (later system will need it)
  mount -t tmpfs tmpfs /run
  # can't be moved for some reason
  # mount -t tmpfs -o nodev,nosuid,noexec shm /dev/shm
}

# Load modules we may need - modules are also loaded if we get to udev
# or nlplug-findfs, but we may skip that if the core modules are enough.
initramfs_mods() {

  # Required on alpine kernel - without this there is no display
  # Debian appears to have it compiled in the kernel.
  modprobe -a simpledrm scsi_mod sd_mod \
     squashfs loop dm-verity mmc_block efivarfs \
     ext4 >> /tmp/initos.log 2>&1

  # For loading recovery from USB disk, kbd
  modprobe -a usbcore ehci-hcd ohci-hcd xhci-hcd usb-storage
  
  # Support scsi disks - needed for sata 
  # nvme appears to be linked in both deb and alpine
  # for loading recovery, modules, firmware
  # btrfs, vfat are are normally present - but may be loaded if missing
}

# Prepare the rootfs:
# - /initos/ro/sidecar should exist and have read-only content either
#   from signed verity images (SECURE=1), unverified sqfs paritions (qemu) or
#   directories on an ext4 filesystem (mounted as /initos/z)
#
# Will:
# - mount overlayfs for sidecar
# - create the expected firmware and modules bind mounts 
# - populate /var/initos with info about the boot and files from initrd
mount_initos() {
  kernel_ver=$(uname -r)
 
  mkdir -p /lib/firmware
  mkdir -p /lib/modules/${kernel_ver}

  mount_overlay sidecar /initos/sidecar
  if [ ! -d /initos/sidecar/etc ]; then
    lfatal "InitOS sidecar is not mounted."
  fi
  if [ ! -d /initos/sidecar/lib/modules/${kernel_ver} ]; then
    lfatal "InitOS sidecar lacks kernel modules $(ls /initos/sidecar/lib/modules)."
  fi

  # The verified sidecar will be the sysroot.
  mount -o bind /initos/sidecar /sysroot

  mkdir -p /sysroot/var/initos
  mkdir -p /sysroot/var/initos/logs

  echo -n ${BOOT_CURRENT} > /sysroot/var/initos/BOOT_CURRENT
  echo -n ${NEXT} > /sysroot/var/initos/BOOT_NEXT
  echo -n ${SECURE_MODE} > /sysroot/var/initos/BOOT_SECURE
  echo -n ${BOOT_DEVICE} > /sysroot/var/initos/BOOT_DEVICE
  # This may be called with cmdline arguments, all that are not used by kernel.
  echo "CMDLINE: $*" > /tmp/initos.log
  env >> /tmp/initos.log
  ls -lR /lib > /sysroot/var/initos/logs/initrd.lslr
  cp /tmp/* /sysroot/var/initos/logs 

  # The files from the signed initrd can override files in the 
  # initos sqfs. It is also possible to append to or rebuild the 
  # sqfs using the docker image.
  # 
  # This can include wpa supplicant file for insecure machines
  # (ideally on a separate net)
  
  # Will be available as /var/initos/local in the init.
  cp -a /local/* /sysroot/var/initos/local  

  # Patch initos scripts to the latest version from initrd (with possible patches) 
  cp /sbin/initos* /sbin/setup-initos* /sysroot/sbin/
  rm -f /sysroot/.dockerenv
}

# Mount an overlayfs on top of a squashfs, dm-verity or other RO device.
# name and destination are needed, device (default to /dev/mapper/NAME)
# and type (default to squashfs) are optional.
mount_overlay() {
  local name=$1
  local dst=$2
  
  local dev=${3:-/dev/mapper/${name}}
  local type=${4:-squashfs}

  mkdir -p ${dst} /initos/ro/${name} /initos/rw/${name} /initos/work/${name} ${dst}
  # logi "Mounting overlay $dev $type to /initos/ro/$name and overlay to $dst"
  # mount -t $type $dev /initos/ro/${name}
  # if [ $? -ne 0 ]; then
  #    lfatal "Error: Failed to mount sqfs ${name}"
  #    return 1
  # fi

  mount -t overlay \
    -o lowerdir=/initos/ro/${name},upperdir=/initos/rw/${name},workdir=/initos/work/${name} \
    overlayfs ${dst}
  if [ $? -ne 0 ]; then
     lfatal "Error: Failed to mount overlay ${name}"
  fi
}

# All remaining mounted dirs will be moved under same dir in /sysroot,
# ready to switch_root
move_mounted_to_sysroot() {
  # Will be started again in sysroot
  udevadm control --exit || true

  # From original alpine init
  cat /proc/mounts 2>/dev/null | while read DEV DIR TYPE OPTS ; do
    if [ "$DIR" != "/" -a "$DIR" != "/sysroot" -a -d "$DIR" ]; then
      mkdir -p /sysroot$DIR
      mount -o move $DIR /sysroot$DIR
    fi
  done

  sync
}

# Info log - shown on console, logged.
logi() {
	last_emsg=""$@""
	echo "INITOSRD: $last_emsg" > /dev/kmsg
	echo "INITOSRD: $last_emsg"
}

lfatal() {
  echo "FAILED: "$@""
  local save=/boot/efi/log
  mkdir -p $save

  blkid > $save/blkid.log
  dmesg > $save/dmesg.log
  cat /proc/filesystems > $save/filesystems
  cat /proc/devices > $save/devices
  lsmod > $save/lsmod.log

  
  # TODO: if /boot/efi is mounted, save to the EFI partition
  blkid
  
  if [ "$SECURE_MODE" = "1" ]; then 
    echo "Rebooting in 20 sec. Block devices:"
    sleep 20
    sync
    reboot -f
  else
    echo "Recovery shell, insecure boot. Fix the issue and exit to continue."
    /bin/sh
  fi
}

# retry function. Not used right now, will be used for LVM open
retry() {
  retries=$1
  shift

  count=0
  until "$@"; do
    exit=$?
    wait=$((count + 1))
    count=$((count + 1))
    if [ "$count" -lt "$retries" ]; then
      #echo "Retry $count/$retries exited $exit, retrying in $wait seconds..."
      sleep $wait
    else
      echo "Retry $count/$retries exited $exit, no more retries left."
      return $exit
    fi
  done
}


# support for eudev. see /etc/init.d/udev*
# At the end we need to call
# udevadm control --exit
# Requires udevd to be added to initramfs.
# Alternative: alpine nlplug-findfs
udev_start() {
  if [ -f /sbin/udevd ]; then
    if [ -e /proc/sys/kernel/hotplug ]; then
      echo "" >/proc/sys/kernel/hotplug
    fi
    [ -d /etc/udev/rules.d ] || mkdir -p /etc/udev/rules.d

    udevd -d

    udevadm hwdb --update

    # Populating /dev with existing devices through uevents
    udevadm trigger --type=subsystems --action=add
    udevadm trigger --type=devices --action=add
	fi
}

# Find_root looks for all EFI partitions, and attempts to mount
# the partition having a file /initos/version with same content
# as the hash of the initos.verity. As long as the hash is matching
# it doesn't matter which partition we use.
#
# There is a risk that the file is corrupted - and the alternate
# partition would be good, but usually the A/B have different 
# versions (previous/next), and on reboot we would pick that.

# Will look for the sidecar image.
#
# Current logic:
# - BTRFS disk with label INITOS or INITOSUSB (new world)
# - EXT4 disk with label H-STATE or UBUNTU (for upgraded laptos - more can be added)
# - FAT (EFI) disk with label BOOTA, BOOTB - to be removed
# 
# The disks are checked for /initos/BOOTA and /initos/BOOTB - and 
# initos.hash and sidecar.hash.
# 
# In insecure mode, the /z/initos/sidecar and /z/initos/oop are also used,
# no signature. If an attacker has access to the machine - they can take control
# anyways by booting another OS.
find_boot() {
  local first=BOOTA
  local second=BOOTB
  export NEXT=B
  if [ "$BOOT_CURRENT" = "1002" ]; then
    # Special case when using the 'alternative' boot partition.
    first=BOOTB
    second=BOOTB
  fi

  # Main file - if /dev/mapper/initos can be mounted, will assume success.
  local vname=initos

  if [ "${SECURE_MODE}" != "1" -a -n "${initos_sidecar}" ]; then
      # Wait for things to settle
      retry 4 [ -e ${initos_sidecar} ]
      mount -t squashfs ${initos_sidecar} /initos/ro/sidecar
      logi "Mounted using dedicated partitions"
      return 0
  fi
  
  # Location on the initramfs where the hashes are stored.
  # Will be matched against disk content under /initos/*.hash
  #local hashf=${2:-$(cat /local/modloop.hash)}
  #local hashf2=${3:-$(cat /local/sidecar.hash)}
  local hashf=${3:-$(cat /local/sidecar.hash)}

  # findfs doesn't work well if multiple partitions with same label are present.
  # This just waits for the expected label to show up, will try all of them
  retry 4 findfs LABEL=$first >/dev/null 2>&1

  # This is too complicated - maybe get rid of it, USB disks should have one partition (BOOTUSB), and install should
  # use the state. First need to update all machines to use the new /z disk.

  for kind in $first $second BOOTUSB "QEMU VVFAT" ;  do
    # This is busybox blkid, lacks '-l'
    device=$(blkid | grep "LABEL=\"$kind\"" | cut -d: -f1)
    if [ -z "$device" ]; then
      continue
    fi
    echo "Looking for signed bootstrap on $kind $device"
    for d in $device ; do 
      try_efi_disk "$d" "$hashf" "$hashf2"
      if [ $? -eq 0 ]; then
        export BOOT_LABEL=$kind
        export BOOT_DEVICE=$d
        if [ "$kind" = "BOOTB" ]; then
          export NEXT=A
        fi
        logi "Mounted SQFS from EFI image ${d} ${kind} ${hashf}"
        export FOO=BAR  
        return 0
      fi
    done
  done

  lfatal "$BOOT_CURRENT SECURE=${SECURE_MODE} - boot partition not found. Expects /boot/efi to be mounted and /dev/mapper/initos verity device to be setup."
}

# Try a vfat BOOT disk: if it has the same hash and verify loads, leave it mounted as 
# /boot/efi and verity 'initos', return 0
# Else return error.
try_efi_disk() {
  local device=$1
  local hashf=$2
  local mountp=/boot/efi
  
  # fsck.vfat -y $device >> /tmp/initos.log 2>&1
  if mount -o ro -t vfat "$device" $mountp ; then
    # Cleanup - it happens if not unmounted safely.
    # rm -f $mountp/FSCK*.REC || true
    
    mount_sidecar $mountp/initos $device $hashf  
    if [ $? -eq 0 ]; then
      return 0
    fi
    logi "  sidecar not found on $device"
    umount $mountp
  else
    logi "  Error: Failed to mount EFI device $device"
  fi
  return 1
}

mount_sidecar() {
  local mountp=$1
  local device=$2
  local hashf=$3

  if [ ! -f ${mountp}/sidecar.hash ]; then
    if [ "${SECURE_MODE}" != "1" -a -f ${mountp}/sidecar.sqfs ]; then 
      mount -t squashfs ${mountp}/sidecar.sqfs /initos/ro/sidecar
      if [ $? -eq 0 ]; then
        return 0
      fi
    fi

    return 3
  fi

  version_content=$(cat $mountp/sidecar.hash)
  if [ "$version_content" = "$hashf" ]; then
    logi "Found InitOS partition $device $hashf"
    
    veritysetup open $mountp/sidecar.sqfs sidecar \
      $mountp/sidecar.sqfs.verity ${hashf} 
    
    if [ $? -eq 0 ]; then
      mount -t squashfs /dev/mapper/sidecar /initos/ro/sidecar
      if [ $? -ne 0 ]; then
        return 2
      fi
      
      return 0 
    fi
    logi "   found InitOS with correct hash, but verity failed, continue $device"
  else 
    logi "  found InitOS partition with different version $version_content on $device expecting $hashf"
  fi
  return 1
}

# We need to find the boot partition, to load the matching signed image.
# EFI is complicated, but really all we care about is if current boot (which is
# stored in a standard location) is odd or even.
# 
# Will set SECURE_MODE and BOOT_CURRENT envs
check_efi() {

  mount -t efivarfs none /sys/firmware/efi/
  if [ $? -ne 0 ]; then
    logi "EFI not supported, insecure mode"
    return 1
  fi

  if [ -e /sys/firmware/efi/efivars/SecureBoot-8be4df61-93ca-11d2-aa0d-00e098032b8c ]; then
    SECURE_MODE=$(od -An -t x4 /sys/firmware/efi/efivars/SecureBoot-8be4df61-93ca-11d2-aa0d-00e098032b8c)
    export SECURE_MODE=${SECURE_MODE:17}
  elif [ -e /sys/firmware/efi/SecureBoot-8be4df61-93ca-11d2-aa0d-00e098032b8c ]; then
    SECURE_MODE=$(od -An -t x4 /sys/firmware/efi/SecureBoot-8be4df61-93ca-11d2-aa0d-00e098032b8c)
    export SECURE_MODE=${SECURE_MODE:17}
  else
    export SECURE_MODE=0
  fi
  # LD_LIBRARY_PATH=/initos/modloop/usr/lib \
  #    /initos/modloop/usr/bin/mokutil --sb-state

  if [ -e /sys/firmware/efi/efivars/BootCurrent-8be4df61-93ca-11d2-aa0d-00e098032b8c ]; then
    bootcurrent=$(od -An -t x4 /sys/firmware/efi/efivars/BootCurrent-8be4df61-93ca-11d2-aa0d-00e098032b8c)
  fi
  if [ -e /sys/firmware/efi/BootCurrent-8be4df61-93ca-11d2-aa0d-00e098032b8c ]; then
    bootcurrent=$(od -An -t x4 /sys/firmware/efi/BootCurrent-8be4df61-93ca-11d2-aa0d-00e098032b8c)
  fi
  # Remove first 4 bytes (attribute bytes, zeros)
  bootcurrent=${bootcurrent:14}
  export BOOT_CURRENT=$bootcurrent
}

# This is called with 'env' set from kernel cmdline - all unknown foo=bar
# Args are all kernel unknown.
if [ "$$" = "1" ]; then
  initramfs_1st
  
  initramfs_init
else
  "$@"
fi
